{
  "_from": "leaflet-geosearch",
  "_id": "leaflet-geosearch@2.7.0",
  "_inBundle": false,
  "_integrity": "sha512-6rZIZ5mp9Ifp3R37DKe7ipHV6/qnUY5kP1gNDz3oMT4hp5FqKyB2V4enoTDT1iziE8yrn0hy/OP9oI4HG1dKEw==",
  "_location": "/leaflet-geosearch",
  "_phantomChildren": {},
  "_requested": {
    "escapedName": "leaflet-geosearch",
    "fetchSpec": "latest",
    "name": "leaflet-geosearch",
    "raw": "leaflet-geosearch",
    "rawSpec": "",
    "registry": true,
    "saveSpec": null,
    "type": "tag"
  },
  "_requiredBy": [
    "#USER"
  ],
  "_resolved": "https://registry.npmjs.org/leaflet-geosearch/-/leaflet-geosearch-2.7.0.tgz",
  "_shasum": "0f7b319486ea344b00639b84b338b4087bf6b839",
  "_spec": "leaflet-geosearch",
  "_where": "C:\\Users\\presldn",
  "author": {
    "email": "stephan@meijer.ws",
    "name": "Stephan Meijer"
  },
  "ava": {
    "babel": "inherit",
    "files": [
      "./src/**/__tests__/**.spec.js"
    ],
    "require": [
      "./test/browserEnv",
      "babel-core/register",
      "dotenv/config",
      "nodent-runtime"
    ]
  },
  "bugs": {
    "url": "https://github.com/smeijer/leaflet-geosearch/issues"
  },
  "bundleDependencies": false,
  "dependencies": {
    "lodash.debounce": "^4.0.8",
    "nodent-runtime": "^3.0.4"
  },
  "deprecated": false,
  "description": "Adds support for address lookup (a.k.a. geocoding / geoseaching) to Leaflet.",
  "devDependencies": {
    "ava": "^0.17.0",
    "babel-cli": "^6.18.0",
    "babel-core": "^6.21.0",
    "babel-eslint": "^7.1.1",
    "babel-loader": "^6.2.10",
    "babel-plugin-transform-class-properties": "^6.19.0",
    "babel-plugin-transform-export-extensions": "^6.8.0",
    "babel-plugin-transform-object-rest-spread": "^6.20.2",
    "babel-plugin-transform-react-jsx": "^6.8.0",
    "babel-polyfill": "^6.23.0",
    "babel-preset-es2015": "^6.18.0",
    "babel-preset-power-assert": "^1.0.0",
    "browser-env": "^2.0.19",
    "cross-env": "^3.1.3",
    "css-loader": "^0.26.1",
    "dotenv": "^2.0.0",
    "eslint": "^3.12.2",
    "eslint-config-airbnb": "^13.0.0",
    "eslint-plugin-import": "^2.2.0",
    "eslint-plugin-jsx-a11y": "^2.2.3",
    "eslint-plugin-react": "^6.8.0",
    "eslint-watch": "^2.1.14",
    "extract-text-webpack-plugin": "^1.0.1",
    "fast-async": "^6.1.2",
    "leaflet": "^1.0.2",
    "lodash.merge": "^4.6.0",
    "microlight": "0.0.7",
    "node-fetch": "^1.6.3",
    "npm": "^4.0.5",
    "power-assert": "^1.4.2",
    "preact": "^8.1.0",
    "raw-loader": "^0.5.1",
    "rimraf": "^2.5.4",
    "style-loader": "^0.13.1",
    "testdouble": "^1.10.1",
    "webpack": "^1.14.0",
    "webpack-dev-server": "^1.16.2",
    "whatwg-fetch": "^2.0.3"
  },
  "directories": {
    "example": "example"
  },
  "files": [
    "assets",
    "dist",
    "lib"
  ],
  "homepage": "https://github.com/smeijer/leaflet-geosearch#readme",
  "keywords": [
    "geo",
    "geocoding",
    "geolocation",
    "leaflet",
    "map",
    "plugins"
  ],
  "license": "MIT",
  "main": "lib/index.js",
  "name": "leaflet-geosearch",
  "optionalDependencies": {},
  "publishConfig": {
    "tag": "latest"
  },
  "readme": "# Leaflet.GeoSearch\r\n\r\n[![Join the chat at https://gitter.im/smeijer/leaflet-geosearch](https://badges.gitter.im/smeijer/leaflet-geosearch.svg)](https://gitter.im/smeijer/leaflet-geosearch?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\r\n\r\n[![build status](https://img.shields.io/travis/smeijer/leaflet-geosearch/master.svg?style=flat-square)][9]\r\n\r\n[![NPM](https://nodei.co/npm/leaflet-geosearch.png?downloads=true)][10]\r\n\r\n\r\n## Installation\r\n\r\nwith npm:\r\n```bash\r\nnpm install --save leaflet-geosearch\r\n```\r\n\r\nor yarn:\r\n```bash\r\nyarn add leaflet-geosearch\r\n```\r\n\r\nor bower:\r\n```bash\r\nbower install leaflet-geosearch\r\n```\r\n\r\nIf you don’t use [npm][11], you may grab the latest [UMD][12] build from \r\n[unpkg][13] (either a [development][14] or a [production][15] build). The UMD build \r\nexports a global called `window.GeoSearch` if you add it to your page via a \r\n`<script>` tag. \r\n\r\nWe *don’t* recommend UMD builds for any serious application.\r\n\r\n## Browser support / Polyfills\r\nThis library is written with the latest technologies in mind. Thereby it is required to include some polyfills when you wish to support older browsers. These polyfills are recommended for IE and Safari support:\r\n\r\n- [babel-polyfill][16], for `array.includes` support.\r\n- [whatwg-fetch][17], for `fetch` requests.\r\n\r\n# About\r\nThis library adds support for geocoding *(address lookup, a.k.a. geoseaching)* \r\nto your (web) application. It comes with controls to be embedded in your \r\n[Leaflet][1]\r\nmap.\r\n\r\nCheck out the [demo][2] for various possibilities.\r\n\r\nThe library uses so-called \"providers\" to take care of building the correct \r\nservice URL and parsing the retrieved data into a uniform format. Thanks to this \r\narchitecture, it is pretty easy to add your own providers, so you can use \r\nyour own geocoding service(s).\r\n\r\nThe control comes with a default set of five providers:\r\n\r\n  - [Bing](#bing-provider).\r\n  - [Esri](#esri-provider).\r\n  - [Google](#google-provider).\r\n  - [OpenStreetMap](#openstreetmap-provider).\r\n  - [LocationIQ](#locationiq-provider).\r\n\r\nAlthough this project is still named `leaflet-geosearch`, this library is also \r\nusable without LeafletJS, and does not have any dependencies whatsoever.\r\n\r\n# Usage\r\n\r\nLet's first start with an little example on how to use this control without \r\nleaflet. For example as an address lookup on a webshop order form. Perhaps to \r\nsearch for the closest alternative package delivery point? Or to link it to your\r\nown custom map component.\r\n\r\n```js\r\n// import\r\nimport { OpenStreetMapProvider } from 'leaflet-geosearch';\r\n\r\n// setup\r\nconst provider = new OpenStreetMapProvider();\r\n\r\n// search\r\nconst results = await provider.search({ query: input.value });\r\n```\r\n\r\nOf course, something like this should be bound to something like a form or \r\ninput:\r\n\r\n```js\r\nimport { OpenStreetMapProvider } from 'leaflet-geosearch';\r\n\r\nconst form = document.querySelector('form');\r\nconst input = form.querySelector('input[type=\"text\"]');\r\n\r\nform.addEventListener('submit', async (event) => {\r\n  event.preventDefault();\r\n\r\n  const results = await provider.search({ query: input.value });\r\n  console.log(results); // » [{}, {}, {}, ...]\r\n});\r\n```\r\n\r\nInstead of es6 `async` / `await` you can also use promises like:\r\n\r\n```js\r\nprovider\r\n  .search({ query: '...' })\r\n  .then(function(result) { \r\n    // do something with result;\r\n  });\r\n```\r\n\r\n## Results\r\n\r\nThe `search` event of all providers return an array of `result objects`. The \r\nbase structure is uniform between the providers. It provides a object like:\r\n\r\n```js\r\nconst result = {\r\n  x: Number,                      // lon,\r\n  y: Number,                      // lat,\r\n  label: String,                  // formatted address\r\n  bounds: [\r\n    [Number, Number],             // s, w - lat, lon\r\n    [Number, Number],             // n, e - lat, lon\r\n  ],\r\n  raw: {},                        // raw provider result\r\n}\r\n```\r\n\r\nThe contents of the `raw` property differ per provider. This is the unprocessed\r\nresult from the 3th party service. This property is included for developer \r\nconvenience. `leaflet-geosearch` does not use it. If you need to know the \r\ncontents of this property, you should check the 3th party developer docs. (or\r\nuse your debugger)\r\n  \r\n# Providers\r\nWhen `OpenStreetMap` does not match your needs; you can also choose to use the \r\n`Bing`, `Esri`, `Google` or `LocationIQ` providers. Those providers do however require API \r\nkeys. See the documentation pages on the relevant organisations on how to obtain \r\nthese keys.\r\n \r\nIn case you decide to write your own provider, please consider submitting a PR\r\nto share your work with us.\r\n\r\nProviders are unaware of any options you can give them. They are simple proxies \r\nto their endpoints. There is only one `special property`, and that is the `params`\r\noption. The difference being; that `params` will be included in the endpoint url. \r\nOften being used for `API KEYS`, where as the other attributes can be used for\r\nprovider configuration.\r\n\r\n## Bing Provider\r\n**note**: Bing services require an API key. [Obtain here][7]. \r\nFor more options and configurations, see the [MSDN developer docs][6].\r\n\r\n```js\r\nimport { BingProvider } from 'leaflet-geosearch';\r\n\r\nconst provider = new BingProvider({ \r\n  params: {\r\n    key: '__YOUR_BING_KEY__'\r\n  },\r\n});\r\n```\r\n\r\n## Esri Provider\r\nFor more options and configurations, see the [ArcGIS developer docs][3].\r\n\r\n```js\r\nimport { EsriProvider } from 'leaflet-geosearch';\r\n\r\nconst provider = new EsriProvider();\r\n```\r\n\r\n## Google Provider\r\n**note**: Google services require an API key. [Obtain here][8].\r\nFor more options and configurations, see the [Google Maps developer docs][4].\r\n\r\n```js\r\nimport { GoogleProvider } from 'leaflet-geosearch';\r\n\r\nconst provider = new GoogleProvider({ \r\n  params: {\r\n    key: '__YOUR_GOOGLE_KEY__',\r\n  },\r\n});\r\n```\r\n\r\n## OpenStreetMap Provider\r\nFor more options and configurations, see the [OpenStreetMap Nominatim wiki][5].\r\n\r\n```js\r\nimport { OpenStreetMapProvider } from 'leaflet-geosearch';\r\n\r\nconst provider = new OpenStreetMapProvider();\r\n```\r\n\r\n## LocationIQ Provider\r\n**note**: LocationIQ services require an API key. [Obtain here][18].\r\nFor more options and configurations, see the [LocationIQ developer docs][19].\r\n\r\n```js\r\nimport { LocationIQProvider } from 'leaflet-geosearch';\r\n\r\nconst provider = new LocationIQProvider({ \r\n  params: {\r\n    key: '__YOUR_LOCATIONIQ_KEY__',\r\n  },\r\n});\r\n```\r\n\r\n# Using with LeafletJS\r\n\r\nThis project comes with a leaflet control to hook the search providers into \r\nleaflet. The example below uses the `OpenStreetMap Provider`, but you can exchange \r\nthis with on of the other included providers as well as your own custom made \r\nproviders. Remember to setup the provider with a `key` when required (Google and \r\nBing for example).\r\n\r\n![search control](./docs/assets/img/searchbar.png)\r\n\r\n```js\r\nimport L from 'leaflet';\r\nimport { GeoSearchControl, OpenStreetMapProvider } from 'leaflet-geosearch';\r\n\r\nconst provider = new OpenStreetMapProvider();\r\n\r\nconst searchControl = new GeoSearchControl({\r\n  provider: provider,\r\n});\r\n\r\nconst map = new L.Map('map');\r\nmap.addControl(searchControl);\r\n```\r\n\r\n## GeoSearchControl\r\nThere are some configurable options like setting the position of the search input\r\nand whether or not a marker should be displayed at the position of the search result.\r\n\r\n![search button](./docs/assets/img/searchbutton.png)\r\nThere are two visual styles of this control. One is the more 'leaflet-way' by \r\nputting the search control under a button (see image above). And one where the \r\nsearch control is permanently shown as a search bar (see image under \r\n[using with LeafletJS](#using-with-leafletjs)).\r\n\r\n**Render style**\r\n\r\nThis render style can be set by the optional `style` option.\r\n\r\n```js\r\nnew GeoSearchControl({\r\n  provider: myProvider,           // required\r\n  style: 'bar',                   // optional: bar|button  - default button\r\n}).addTo(map);\r\n```\r\n\r\n**AutoComplete** \r\n\r\nAuto complete can be configured by the parameters `autoComplete` and \r\n`autoCompleteDelay`. A little delay is required to not DDOS the server on every\r\nkeystroke.\r\n\r\n```js\r\nnew GeoSearchControl({\r\n  provider: myProvider,           // required\r\n  autoComplete: true,             // optional: true|false  - default true\r\n  autoCompleteDelay: 250,         // optional: number      - default 250\r\n}).addTo(map);\r\n```\r\n\r\n**Show result**\r\n\r\nThere are a number of options to adjust the way results are visualized.\r\n \r\n```js\r\nnew GeoSearchControl({\r\n  provider: myProvider,                               // required\r\n  showMarker: true,                                   // optional: true|false  - default true\r\n  showPopup: false,                                   // optional: true|false  - default false\r\n  marker: {                                           // optional: L.Marker    - default L.Icon.Default\r\n    icon: new L.Icon.Default(),\r\n    draggable: false,\r\n  },\r\n  popupFormat: ({ query, result }) => result.label,   // optional: function    - default returns result label\r\n  maxMarkers: 1,                                      // optional: number      - default 1\r\n  retainZoomLevel: false,                             // optional: true|false  - default false\r\n  animateZoom: true,                                  // optional: true|false  - default true\r\n  autoClose: false,                                   // optional: true|false  - default false\r\n  searchLabel: 'Enter address',                       // optional: string      - default 'Enter address'\r\n  keepResult: false                                   // optional: true|false  - default false\r\n});\r\n```\r\n\r\n`showMarker` and `showPopup` determine whether or not to show a marker and/or \r\nopen a popup with the location text.\r\n\r\n`marker` can be set to any instance of a (custom) `L.Icon`.\r\n\r\n`popupFormat` is callback function for displaying text on popup.\r\n\r\n`maxMarker` determines how many last results are kept in memory. Default 1, but\r\nperhaps you want to show the last `x` results when searching for new queries as \r\nwell.\r\n\r\n`retainZoomLevel` is a setting that fixes the zoomlevel. Default behaviour is to\r\nzoom and pan to the search result. With `retainZoomLevel` on `true`, the map is\r\nonly panned.\r\n\r\n`animateZoom` controls whether or not the pan/zoom moment is being animated.\r\n\r\n`autoClose` closes the result list if a result is selected by click/enter.\r\n\r\n`keepResult` is used to keep the selected result in the search field. This prevents markers to disappear while using the `autoClose` feature. \r\n\r\n**Events**\r\n\r\n`geosearch/showlocation` is fired when location is chosen from the result list.\r\n\r\n```js\r\nmap.on('geosearch/showlocation', yourEventHandler)\r\n```\r\n\r\n`geosearch/marker/dragend` is fired when marker has been dragged.\r\n\r\n```js\r\nmap.on('geosearch/marker/dragend', yourEventHandler)\r\n```\r\n\r\n# Development\r\n\r\nCheckout the providers to see how easy it is to write your own. For research it\r\ncan be interesting to see the difference between Bing and the others; because\r\nBing does not support `CORS`, and requires `jsonp` to be used instead.\r\n\r\nIn case you decide to write your own provider, please consider submitting a PR\r\nto share your work with us.\r\n\r\n[1]: http://leafletjs.com\r\n[2]: http://smeijer.github.io/leaflet-geosearch\r\n[3]: https://developers.arcgis.com/rest/geocode/api-reference/overview-world-geocoding-service.htm\r\n[4]: https://developers.google.com/maps/documentation/geocoding/start\r\n[5]: http://wiki.openstreetmap.org/wiki/Nominatim\r\n[6]: https://msdn.microsoft.com/en-us/library/ff701714.aspx\r\n[7]: https://msdn.microsoft.com/nl-nl/library/ff428642.aspx\r\n[8]: https://developers.google.com/maps/documentation/javascript/get-api-key\r\n[9]: https://travis-ci.org/smeijer/leaflet-geosearch\r\n[10]: https://nodei.co/npm/leaflet-geosearch\r\n[11]: https://www.npmjs.com\r\n[12]: https://unpkg.com/leaflet-geosearch@latest/dist/\r\n[13]: https://unpkg.com\r\n[14]: https://unpkg.com/leaflet-geosearch@latest/dist/bundle.js\r\n[15]: https://unpkg.com/leaflet-geosearch@latest/dist/bundle.min.js\r\n[16]: https://www.npmjs.com/package/babel-polyfill\r\n[17]: https://www.npmjs.com/package/whatwg-fetch\r\n[18]: https://locationiq.org\r\n[19]: https://locationiq.org/#docs\r\n",
  "readmeFilename": "readme.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/smeijer/leaflet-geosearch.git"
  },
  "scripts": {
    "build": "npm run clean && npm run build:commonjs && npm run build:umd && npm run build:umd:min && npm run build:docs",
    "build:commonjs": "babel src --out-dir lib --ignore *.spec.js",
    "build:docs": "cross-env NODE_ENV=production webpack --config webpack.docs.config.babel.js",
    "build:umd": "cross-env NODE_ENV=development webpack",
    "build:umd:min": "cross-env NODE_ENV=production webpack",
    "build:watch": "npm run build:umd -- --watch",
    "clean": "rimraf lib dist",
    "lint": "esw src webpack.config --color",
    "lint:fix": "npm run lint -- --fix",
    "lint:watch": "npm run lint -- --watch",
    "prepublish": "npm run lint && npm run test && npm run build",
    "start": "webpack-dev-server",
    "test": "ava",
    "test:cover": "nyc ava",
    "test:report": "nyc report --reporter html",
    "test:watch": "ava -w"
  },
  "version": "2.7.0"
}
