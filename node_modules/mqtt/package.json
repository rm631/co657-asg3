{
  "_from": "mqtt",
  "_id": "mqtt@2.18.8",
  "_inBundle": false,
  "_integrity": "sha512-3h6oHlPY/yWwtC2J3geraYRtVVoRM6wdI+uchF4nvSSafXPZnaKqF8xnX+S22SU/FcgEAgockVIlOaAX3fkMpA==",
  "_location": "/mqtt",
  "_phantomChildren": {},
  "_requested": {
    "escapedName": "mqtt",
    "fetchSpec": "latest",
    "name": "mqtt",
    "raw": "mqtt",
    "rawSpec": "",
    "registry": true,
    "saveSpec": null,
    "type": "tag"
  },
  "_requiredBy": [
    "#USER"
  ],
  "_resolved": "https://registry.npmjs.org/mqtt/-/mqtt-2.18.8.tgz",
  "_shasum": "9d213ccab92151accfb21ee8c0860dc6866ab259",
  "_spec": "mqtt",
  "_where": "D:\\Media\\Documents\\GitHub\\uni\\co657-asg3",
  "bin": {
    "mqtt": "./mqtt.js",
    "mqtt_pub": "./bin/pub.js",
    "mqtt_sub": "./bin/sub.js"
  },
  "browser": {
    "./mqtt.js": "./lib/connect/index.js",
    "fs": false,
    "net": false,
    "tls": false
  },
  "bugs": {
    "url": "https://github.com/mqttjs/MQTT.js/issues"
  },
  "bundleDependencies": false,
  "contributors": [
    {
      "name": "Adam Rudd",
      "email": "adamvrr@gmail.com"
    },
    {
      "name": "Matteo Collina",
      "email": "matteo.collina@gmail.com",
      "url": "https://github.com/mcollina"
    }
  ],
  "dependencies": {
    "commist": "^1.0.0",
    "concat-stream": "^1.6.2",
    "end-of-stream": "^1.4.1",
    "es6-map": "^0.1.5",
    "help-me": "^1.0.1",
    "inherits": "^2.0.3",
    "minimist": "^1.2.0",
    "mqtt-packet": "^5.6.0",
    "pump": "^3.0.0",
    "readable-stream": "^2.3.6",
    "reinterval": "^1.1.0",
    "split2": "^2.1.1",
    "websocket-stream": "^5.1.2",
    "xtend": "^4.0.1"
  },
  "deprecated": false,
  "description": "A library for the MQTT protocol",
  "devDependencies": {
    "@types/node": "^8.10.21",
    "browserify": "^16.2.2",
    "codecov": "^3.0.4",
    "global": "^4.3.2",
    "istanbul": "^0.4.5",
    "mkdirp": "^0.5.1",
    "mocha": "^4.1.0",
    "mqtt-connection": "^3.0.0",
    "pre-commit": "^1.2.2",
    "rimraf": "^2.6.2",
    "safe-buffer": "^5.1.2",
    "should": "^13.2.1",
    "sinon": "~1.17.7",
    "snazzy": "^7.1.1",
    "standard": "^11.0.1",
    "through2": "^2.0.3",
    "tslint": "^5.11.0",
    "tslint-config-standard": "^7.1.0",
    "typescript": "^2.9.2",
    "uglify-js": "^3.4.5",
    "ws": "^3.3.3",
    "zuul": "^3.12.0",
    "zuul-ngrok": "^4.0.0"
  },
  "engines": {
    "node": ">=4.0.0"
  },
  "files": [
    "CONTRIBUTING.md",
    "bin",
    "dist/",
    "doc",
    "examples",
    "lib",
    "mqtt.js",
    "test",
    "types"
  ],
  "homepage": "https://github.com/mqttjs/MQTT.js#readme",
  "keywords": [
    "mqtt",
    "publish",
    "publish/subscribe",
    "subscribe"
  ],
  "license": "MIT",
  "main": "mqtt.js",
  "name": "mqtt",
  "optionalDependencies": {},
  "pre-commit": [
    "test",
    "tslint"
  ],
  "readme": "![mqtt.js](https://raw.githubusercontent.com/mqttjs/MQTT.js/137ee0e3940c1f01049a30248c70f24dc6e6f829/MQTT.js.png)\r\n=======\r\n\r\n[![Build Status](https://travis-ci.org/mqttjs/MQTT.js.svg)](https://travis-ci.org/mqttjs/MQTT.js) [![codecov](https://codecov.io/gh/mqttjs/MQTT.js/branch/master/graph/badge.svg)](https://codecov.io/gh/mqttjs/MQTT.js)\r\n\r\n[![NPM](https://nodei.co/npm-dl/mqtt.png)](https://nodei.co/npm/mqtt/) [![NPM](https://nodei.co/npm/mqtt.png)](https://nodei.co/npm/mqtt/)\r\n\r\n[![Sauce Test Status](https://saucelabs.com/browser-matrix/mqttjs.svg)](https://saucelabs.com/u/mqttjs)\r\n\r\nMQTT.js is a client library for the [MQTT](http://mqtt.org/) protocol, written\r\nin JavaScript for node.js and the browser.\r\n\r\n* [Upgrade notes](#notes)\r\n* [Installation](#install)\r\n* [Example](#example)\r\n* [Command Line Tools](#cli)\r\n* [API](#api)\r\n* [Browser](#browser)\r\n* [Weapp](#weapp)\r\n* [About QoS](#qos)\r\n* [TypeScript](#typescript)\r\n* [Contributing](#contributing)\r\n* [License](#license)\r\n\r\nMQTT.js is an OPEN Open Source Project, see the [Contributing](#contributing) section to find out what this means.\r\n\r\n[![JavaScript Style\r\nGuide](https://cdn.rawgit.com/feross/standard/master/badge.svg)](https://github.com/feross/standard)\r\n\r\n\r\n<a name=\"notes\"></a>\r\n## Important notes for existing users\r\n\r\nv2.0.0 removes support for node v0.8, v0.10 and v0.12, and it is 3x faster in sending\r\npackets. It also removes all the deprecated functionality in v1.0.0,\r\nmainly `mqtt.createConnection` and `mqtt.Server`. From v2.0.0,\r\nsubscriptions are restored upon reconnection if `clean: true`.\r\nv1.x.x is now in *LTS*, and it will keep being supported as long as\r\nthere are v0.8, v0.10 and v0.12 users.\r\n\r\nv1.0.0 improves the overall architecture of the project, which is now\r\nsplit into three components: MQTT.js keeps the Client,\r\n[mqtt-connection](http://npm.im/mqtt-connection) includes the barebone\r\nConnection code for server-side usage, and [mqtt-packet](http://npm.im/mqtt-packet)\r\nincludes the protocol parser and generator. The new Client improves\r\nperformance by a 30% factor, embeds Websocket support\r\n([MOWS](http://npm.im/mows) is now deprecated), and it has a better\r\nsupport for QoS 1 and 2. The previous API is still supported but\r\ndeprecated, as such, it is not documented in this README.\r\n\r\nAs a __breaking change__, the `encoding` option in the old client is\r\nremoved, and now everything is UTF-8 with the exception of the\r\n`password` in the CONNECT message and `payload` in the PUBLISH message,\r\nwhich are `Buffer`.\r\n\r\nAnother __breaking change__ is that MQTT.js now defaults to MQTT v3.1.1,\r\nso to support old brokers, please read the [client options doc](#client).\r\n\r\n<a name=\"install\"></a>\r\n## Installation\r\n\r\n```sh\r\nnpm install mqtt --save\r\n```\r\n\r\n<a name=\"example\"></a>\r\n## Example\r\n\r\nFor the sake of simplicity, let's put the subscriber and the publisher in the same file:\r\n\r\n```js\r\nvar mqtt = require('mqtt')\r\nvar client  = mqtt.connect('mqtt://test.mosquitto.org')\r\n\r\nclient.on('connect', function () {\r\n  client.subscribe('presence', function (err) {\r\n    if (!err) {\r\n      client.publish('presence', 'Hello mqtt')\r\n    }\r\n  })\r\n})\r\n\r\nclient.on('message', function (topic, message) {\r\n  // message is Buffer\r\n  console.log(message.toString())\r\n  client.end()\r\n})\r\n```\r\n\r\noutput:\r\n```\r\nHello mqtt\r\n```\r\n\r\nIf you want to run your own MQTT broker, you can use\r\n[Mosquitto](http://mosquitto.org) or\r\n[Mosca](http://mcollina.github.io/mosca/), and launch it.\r\nYou can also use a test instance: test.mosquitto.org and test.mosca.io\r\nare both public.\r\n\r\nIf you do not want to install a separate broker, you can try using the\r\n[mqtt-connection](https://www.npmjs.com/package/mqtt-connection).\r\n\r\nto use MQTT.js in the browser see the [browserify](#browserify) section\r\n\r\n<a name=\"promises\"></a>\r\n## Promise support\r\n\r\nIf you want to use the new [async-await](https://blog.risingstack.com/async-await-node-js-7-nightly/) functionality in JavaScript, or just prefer using Promises instead of callbacks, [async-mqtt](https://github.com/mqttjs/async-mqtt) is a wrapper over MQTT.js which uses promises instead of callbacks when possible.\r\n\r\n<a name=\"cli\"></a>\r\n## Command Line Tools\r\n\r\nMQTT.js bundles a command to interact with a broker.\r\nIn order to have it available on your path, you should install MQTT.js\r\nglobally:\r\n\r\n```sh\r\nnpm install mqtt -g\r\n```\r\n\r\nThen, on one terminal\r\n\r\n```\r\nmqtt sub -t 'hello' -h 'test.mosquitto.org' -v\r\n```\r\n\r\nOn another\r\n\r\n```\r\nmqtt pub -t 'hello' -h 'test.mosquitto.org' -m 'from MQTT.js'\r\n```\r\n\r\nSee `mqtt help <command>` for the command help.\r\n\r\n<a name=\"api\"></a>\r\n## API\r\n\r\n  * <a href=\"#connect\"><code>mqtt.<b>connect()</b></code></a>\r\n  * <a href=\"#client\"><code>mqtt.<b>Client()</b></code></a>\r\n  * <a href=\"#publish\"><code>mqtt.Client#<b>publish()</b></code></a>\r\n  * <a href=\"#subscribe\"><code>mqtt.Client#<b>subscribe()</b></code></a>\r\n  * <a href=\"#unsubscribe\"><code>mqtt.Client#<b>unsubscribe()</b></code></a>\r\n  * <a href=\"#end\"><code>mqtt.Client#<b>end()</b></code></a>\r\n  * <a href=\"#removeOutgoingMessage\"><code>mqtt.Client#<b>removeOutgoingMessage()</b></code></a>\r\n  * <a href=\"#reconnect\"><code>mqtt.Client#<b>reconnect()</b></code></a>\r\n  * <a href=\"#handleMessage\"><code>mqtt.Client#<b>handleMessage()</b></code></a>\r\n  * <a href=\"#connected\"><code>mqtt.Client#<b>connected</b></code></a>\r\n  * <a href=\"#reconnecting\"><code>mqtt.Client#<b>reconnecting</b></code></a>\r\n  * <a href=\"#getLastMessageId\"><code>mqtt.Client#<b>getLastMessageId()</b></code></a>\r\n  * <a href=\"#store\"><code>mqtt.<b>Store()</b></code></a>\r\n  * <a href=\"#put\"><code>mqtt.Store#<b>put()</b></code></a>\r\n  * <a href=\"#del\"><code>mqtt.Store#<b>del()</b></code></a>\r\n  * <a href=\"#createStream\"><code>mqtt.Store#<b>createStream()</b></code></a>\r\n  * <a href=\"#close\"><code>mqtt.Store#<b>close()</b></code></a>\r\n\r\n-------------------------------------------------------\r\n<a name=\"connect\"></a>\r\n### mqtt.connect([url], options)\r\n\r\nConnects to the broker specified by the given url and options and\r\nreturns a [Client](#client).\r\n\r\nThe URL can be on the following protocols: 'mqtt', 'mqtts', 'tcp',\r\n'tls', 'ws', 'wss'. The URL can also be an object as returned by\r\n[`URL.parse()`](http://nodejs.org/api/url.html#url_url_parse_urlstr_parsequerystring_slashesdenotehost),\r\nin that case the two objects are merged, i.e. you can pass a single\r\nobject with both the URL and the connect options.\r\n\r\nYou can also specify a `servers` options with content: `[{ host:\r\n'localhost', port: 1883 }, ... ]`, in that case that array is iterated\r\nat every connect.\r\n\r\nFor all MQTT-related options, see the [Client](#client)\r\nconstructor.\r\n\r\n-------------------------------------------------------\r\n<a name=\"client\"></a>\r\n### mqtt.Client(streamBuilder, options)\r\n\r\nThe `Client` class wraps a client connection to an\r\nMQTT broker over an arbitrary transport method (TCP, TLS,\r\nWebSocket, ecc).\r\n\r\n`Client` automatically handles the following:\r\n\r\n* Regular server pings\r\n* QoS flow\r\n* Automatic reconnections\r\n* Start publishing before being connected\r\n\r\nThe arguments are:\r\n\r\n* `streamBuilder` is a function that returns a subclass of the `Stream` class that supports\r\nthe `connect` event. Typically a `net.Socket`.\r\n* `options` is the client connection options (see: the [connect packet](https://github.com/mcollina/mqtt-packet#connect)). Defaults:\r\n  * `wsOptions`: is the WebSocket connection options. Default is `{}`.\r\n     It's specific for WebSockets. For possible options have a look at: https://github.com/websockets/ws/blob/master/doc/ws.md.\r\n  * `keepalive`: `60` seconds, set to `0` to disable\r\n  * `reschedulePings`: reschedule ping messages after sending packets (default `true`)\r\n  * `clientId`: `'mqttjs_' + Math.random().toString(16).substr(2, 8)`\r\n  * `protocolId`: `'MQTT'`\r\n  * `protocolVersion`: `4`\r\n  * `clean`: `true`, set to false to receive QoS 1 and 2 messages while\r\n    offline\r\n  * `reconnectPeriod`: `1000` milliseconds, interval between two\r\n    reconnections\r\n  * `connectTimeout`: `30 * 1000` milliseconds, time to wait before a\r\n    CONNACK is received\r\n  * `username`: the username required by your broker, if any\r\n  * `password`: the password required by your broker, if any\r\n  * `incomingStore`: a [Store](#store) for the incoming packets\r\n  * `outgoingStore`: a [Store](#store) for the outgoing packets\r\n  * `queueQoSZero`: if connection is broken, queue outgoing QoS zero messages (default `true`)\r\n  * `will`: a message that will sent by the broker automatically when\r\n     the client disconnect badly. The format is:\r\n    * `topic`: the topic to publish\r\n    * `payload`: the message to publish\r\n    * `qos`: the QoS\r\n    * `retain`: the retain flag\r\n  * `transformWsUrl` : optional `(url, options, client) => url` function\r\n        For ws/wss protocols only. Can be used to implement signing\r\n        urls which upon reconnect can have become expired.\r\n  * `resubscribe` : if connection is broken and reconnects,\r\n     subscribed topics are automatically subscribed again (default `true`)\r\n\r\nIn case mqtts (mqtt over tls) is required, the `options` object is\r\npassed through to\r\n[`tls.connect()`](http://nodejs.org/api/tls.html#tls_tls_connect_options_callback).\r\nIf you are using a **self-signed certificate**, pass the `rejectUnauthorized: false` option.\r\nBeware that you are exposing yourself to man in the middle attacks, so it is a configuration\r\nthat is not recommended for production environments.\r\n\r\nIf you are connecting to a broker that supports only MQTT 3.1 (not\r\n3.1.1 compliant), you should pass these additional options:\r\n\r\n```js\r\n{\r\n  protocolId: 'MQIsdp',\r\n  protocolVersion: 3\r\n}\r\n```\r\n\r\nThis is confirmed on RabbitMQ 3.2.4, and on Mosquitto < 1.3. Mosquitto\r\nversion 1.3 and 1.4 works fine without those.\r\n\r\n#### Event `'connect'`\r\n\r\n`function (connack) {}`\r\n\r\nEmitted on successful (re)connection (i.e. connack rc=0).\r\n* `connack` received connack packet. When `clean` connection option is `false` and server has a previous session\r\nfor `clientId` connection option, then `connack.sessionPresent` flag is `true`. When that is the case,\r\nyou may rely on stored session and prefer not to send subscribe commands for the client.\r\n\r\n#### Event `'reconnect'`\r\n\r\n`function () {}`\r\n\r\nEmitted when a reconnect starts.\r\n\r\n#### Event `'close'`\r\n\r\n`function () {}`\r\n\r\nEmitted after a disconnection.\r\n\r\n#### Event `'offline'`\r\n\r\n`function () {}`\r\n\r\nEmitted when the client goes offline.\r\n\r\n#### Event `'error'`\r\n\r\n`function (error) {}`\r\n\r\nEmitted when the client cannot connect (i.e. connack rc != 0) or when a\r\nparsing error occurs.\r\n\r\n#### Event `'end'`\r\n\r\n`function () {}`\r\n\r\nEmitted when <a href=\"#end\"><code>mqtt.Client#<b>end()</b></code></a> is called.\r\nIf a callback was passed to `mqtt.Client#end()`, this event is emitted once the\r\ncallback returns.\r\n\r\n#### Event `'message'`\r\n\r\n`function (topic, message, packet) {}`\r\n\r\nEmitted when the client receives a publish packet\r\n* `topic` topic of the received packet\r\n* `message` payload of the received packet\r\n* `packet` received packet, as defined in\r\n  [mqtt-packet](https://github.com/mcollina/mqtt-packet#publish)\r\n\r\n#### Event `'packetsend'`\r\n\r\n`function (packet) {}`\r\n\r\nEmitted when the client sends any packet. This includes .published() packets\r\nas well as packets used by MQTT for managing subscriptions and connections\r\n* `packet` received packet, as defined in\r\n  [mqtt-packet](https://github.com/mcollina/mqtt-packet)\r\n\r\n#### Event `'packetreceive'`\r\n\r\n`function (packet) {}`\r\n\r\nEmitted when the client receives any packet. This includes packets from\r\nsubscribed topics as well as packets used by MQTT for managing subscriptions\r\nand connections\r\n* `packet` received packet, as defined in\r\n  [mqtt-packet](https://github.com/mcollina/mqtt-packet)\r\n\r\n-------------------------------------------------------\r\n<a name=\"publish\"></a>\r\n### mqtt.Client#publish(topic, message, [options], [callback])\r\n\r\nPublish a message to a topic\r\n\r\n* `topic` is the topic to publish to, `String`\r\n* `message` is the message to publish, `Buffer` or `String`\r\n* `options` is the options to publish with, including:\r\n  * `qos` QoS level, `Number`, default `0`\r\n  * `retain` retain flag, `Boolean`, default `false`\r\n  * `dup` mark as duplicate flag, `Boolean`, default `false`\r\n* `callback` - `function (err)`, fired when the QoS handling completes,\r\n  or at the next tick if QoS 0. An error occurs if client is disconnecting.\r\n\r\n-------------------------------------------------------\r\n<a name=\"subscribe\"></a>\r\n### mqtt.Client#subscribe(topic/topic array/topic object, [options], [callback])\r\n\r\nSubscribe to a topic or topics\r\n\r\n* `topic` is a `String` topic to subscribe to or an `Array` of\r\n  topics to subscribe to. It can also be an object, it has as object\r\n  keys the topic name and as value the QoS, like `{'test1': 0, 'test2': 1}`.\r\n  MQTT `topic` wildcard characters are supported (`+` - for single level and `#` - for multi level)\r\n* `options` is the options to subscribe with, including:\r\n  * `qos` qos subscription level, default 0\r\n* `callback` - `function (err, granted)`\r\n  callback fired on suback where:\r\n  * `err` a subscription error or an error that occurs when client is disconnecting\r\n  * `granted` is an array of `{topic, qos}` where:\r\n    * `topic` is a subscribed to topic\r\n    * `qos` is the granted qos level on it\r\n\r\n-------------------------------------------------------\r\n<a name=\"unsubscribe\"></a>\r\n### mqtt.Client#unsubscribe(topic/topic array, [callback])\r\n\r\nUnsubscribe from a topic or topics\r\n\r\n* `topic` is a `String` topic or an array of topics to unsubscribe from\r\n* `callback` - `function (err)`, fired on unsuback. An error occurs if client is disconnecting.\r\n\r\n-------------------------------------------------------\r\n<a name=\"end\"></a>\r\n### mqtt.Client#end([force], [cb])\r\n\r\nClose the client, accepts the following options:\r\n\r\n* `force`: passing it to true will close the client right away, without\r\n  waiting for the in-flight messages to be acked. This parameter is\r\n  optional.\r\n* `cb`: will be called when the client is closed. This parameter is\r\n  optional.\r\n\r\n-------------------------------------------------------\r\n<a name=\"removeOutgoingMessage\"></a>\r\n### mqtt.Client#removeOutgoingMessage(mid)\r\n\r\nRemove a message from the outgoingStore.\r\nThe outgoing callback will be called with Error('Message removed') if the message is removed.\r\n\r\nAfter this function is called, the messageId is released and becomes reusable.\r\n\r\n* `mid`: The messageId of the message in the outgoingStore.\r\n\r\n-------------------------------------------------------\r\n<a name=\"reconnect\"></a>\r\n### mqtt.Client#reconnect()\r\n\r\nConnect again using the same options as connect()\r\n\r\n-------------------------------------------------------\r\n<a name=\"handleMessage\"></a>\r\n### mqtt.Client#handleMessage(packet, callback)\r\n\r\nHandle messages with backpressure support, one at a time.\r\nOverride at will, but __always call `callback`__, or the client\r\nwill hang.\r\n\r\n-------------------------------------------------------\r\n<a name=\"connected\"></a>\r\n### mqtt.Client#connected\r\n\r\nBoolean : set to `true` if the client is connected. `false` otherwise.\r\n\r\n-------------------------------------------------------\r\n<a name=\"getLastMessageId\"></a>\r\n### mqtt.Client#getLastMessageId()\r\n\r\nNumber : get last message id. This is for sent messages only.\r\n\r\n-------------------------------------------------------\r\n<a name=\"reconnecting\"></a>\r\n### mqtt.Client#reconnecting\r\n\r\nBoolean : set to `true` if the client is trying to reconnect to the server. `false` otherwise.\r\n\r\n-------------------------------------------------------\r\n<a name=\"store\"></a>\r\n### mqtt.Store(options)\r\n\r\nIn-memory implementation of the message store.\r\n\r\n* `options` is the store options:\r\n  * `clean`: `true`, clean inflight messages when close is called (default `true`)\r\n\r\nOther implementations of `mqtt.Store`:\r\n\r\n* [mqtt-level-store](http://npm.im/mqtt-level-store) which uses\r\n  [Level-browserify](http://npm.im/level-browserify) to store the inflight\r\n  data, making it usable both in Node and the Browser.\r\n* [mqtt-nedbb-store](https://github.com/behrad/mqtt-nedb-store) which\r\n  uses [nedb](https://www.npmjs.com/package/nedb) to store the inflight\r\n  data.\r\n* [mqtt-localforage-store](http://npm.im/mqtt-localforage-store) which uses\r\n  [localForage](http://npm.im/localforage) to store the inflight\r\n  data, making it usable in the Browser without browserify.\r\n\r\n-------------------------------------------------------\r\n<a name=\"put\"></a>\r\n### mqtt.Store#put(packet, callback)\r\n\r\nAdds a packet to the store, a packet is\r\nanything that has a `messageId` property.\r\nThe callback is called when the packet has been stored.\r\n\r\n-------------------------------------------------------\r\n<a name=\"createStream\"></a>\r\n### mqtt.Store#createStream()\r\n\r\nCreates a stream with all the packets in the store.\r\n\r\n-------------------------------------------------------\r\n<a name=\"del\"></a>\r\n### mqtt.Store#del(packet, cb)\r\n\r\nRemoves a packet from the store, a packet is\r\nanything that has a `messageId` property.\r\nThe callback is called when the packet has been removed.\r\n\r\n-------------------------------------------------------\r\n<a name=\"close\"></a>\r\n### mqtt.Store#close(cb)\r\n\r\nCloses the Store.\r\n\r\n<a name=\"browser\"></a>\r\n## Browser\r\n\r\n<a name=\"cdn\"></a>\r\n### Via CDN\r\n\r\nThe MQTT.js bundle is available through http://unpkg.com, specifically\r\nat https://unpkg.com/mqtt/dist/mqtt.min.js.\r\nSee http://unpkg.com for the full documentation on version ranges.\r\n\r\n<a name=\"weapp\"></a>\r\n## Weixin App\r\nSurport [Weixin App](https://mp.weixin.qq.com/). See [Doc](https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-socket.html).\r\n<a name=\"example\"></a>\r\n\r\n## Example(js)\r\n\r\n```js\r\nvar mqtt = require('mqtt')\r\nvar client  = mqtt.connect('wxs://test.mosquitto.org')\r\n```\r\n\r\n## Example(ts)\r\n\r\n```ts\r\nimport { connect } from 'mqtt';\r\nconst client  = connect('wxs://test.mosquitto.org');\r\n```\r\n\r\n<a name=\"browserify\"></a>\r\n### Browserify\r\n\r\nIn order to use MQTT.js as a browserify module you can either require it in your browserify bundles or build it as a stand alone module. The exported module is AMD/CommonJs compatible and it will add an object in the global space.\r\n\r\n```javascript\r\nnpm install -g browserify // install browserify\r\ncd node_modules/mqtt\r\nnpm install . // install dev dependencies\r\nbrowserify mqtt.js -s mqtt > browserMqtt.js // require mqtt in your client-side app\r\n```\r\n\r\n<a name=\"webpack\"></a>\r\n### Webpack\r\n\r\nJust like browserify, export MQTT.js as library. The exported module would be `var mqtt = xxx` and it will add an object in the global space. You could also export module in other [formats (AMD/CommonJS/others)](http://webpack.github.io/docs/configuration.html#output-librarytarget) by setting **output.libraryTarget** in webpack configuration.\r\n\r\n```javascript\r\nnpm install -g webpack // install webpack\r\n\r\ncd node_modules/mqtt\r\nnpm install . // install dev dependencies\r\nwebpack mqtt.js ./browserMqtt.js --output-library mqtt\r\n```\r\n\r\nyou can then use mqtt.js in the browser with the same api than node's one.\r\n\r\n```html\r\n<html>\r\n<head>\r\n  <title>test Ws mqtt.js</title>\r\n</head>\r\n<body>\r\n<script src=\"./browserMqtt.js\"></script>\r\n<script>\r\n  var client = mqtt.connect() // you add a ws:// url here\r\n  client.subscribe(\"mqtt/demo\")\r\n\r\n  client.on(\"message\", function (topic, payload) {\r\n    alert([topic, payload].join(\": \"))\r\n    client.end()\r\n  })\r\n\r\n  client.publish(\"mqtt/demo\", \"hello world!\")\r\n</script>\r\n</body>\r\n</html>\r\n```\r\n\r\nYour broker should accept websocket connection (see [MQTT over Websockets](https://github.com/mcollina/mosca/wiki/MQTT-over-Websockets) to setup [Mosca](http://mcollina.github.io/mosca/)).\r\n\r\n<a name=\"signedurls\"></a>\r\n### Signed WebSocket Urls\r\n\r\nIf you need to sign an url, for example for [AWS IoT](http://docs.aws.amazon.com/iot/latest/developerguide/protocols.html#mqtt-ws),\r\nthen you can pass in a `transformWsUrl` function to the <a href=\"#connect\"><code>mqtt.<b>connect()</b></code></a> options\r\nThis is needed because signed urls have an expiry and eventually upon reconnects, a new signed url needs to be created:\r\n\r\n```js\r\n// This module doesn't actually exist, just an example\r\nvar awsIotUrlSigner = require('awsIotUrlSigner')\r\nmqtt.connect('wss://a2ukbzaqo9vbpb.iot.ap-southeast-1.amazonaws.com/mqtt', {\r\n  transformWsUrl: function (url, options, client) {\r\n    // It's possible to inspect some state on options(pre parsed url components)\r\n    // and the client (reconnect state etc)\r\n    return awsIotUrlSigner(url)\r\n  }\r\n})\r\n\r\n// Now every time a new WebSocket connection is opened (hopefully not that\r\n// often) we get a freshly signed url\r\n\r\n```\r\n\r\n<a name=\"qos\"></a>\r\n## About QoS\r\n\r\nHere is how QoS works:\r\n\r\n* QoS 0 : received **at most once** : The packet is sent, and that's it. There is no validation about whether it has been received.\r\n* QoS 1 : received **at least once** : The packet is sent and stored as long as the client has not received a confirmation from the server. MQTT ensures that it *will* be received, but there can be duplicates.\r\n* QoS 2 : received **exactly once** : Same as QoS 1 but there is no duplicates.\r\n\r\nAbout data consumption, obviously, QoS 2 > QoS 1 > QoS 0, if that's a concern to you.\r\n\r\n<a name=\"typescript\"></a>\r\n## Usage with TypeScript\r\nThis repo bundles TypeScript definition files for use in TypeScript projects and to support tools that can read `.d.ts` files.\r\n\r\n### Pre-requisites\r\nBefore you can begin using these TypeScript definitions with your project, you need to make sure your project meets a few of these requirements:\r\n * TypeScript >= 2.1\r\n * Set tsconfig.json: `{\"compilerOptions\" : {\"moduleResolution\" : \"node\"}, ...}`\r\n * Includes the TypeScript definitions for node. You can use npm to install this by typing the following into a terminal window:\r\n   `npm install --save-dev @types/node`\r\n\r\n<a name=\"contributing\"></a>\r\n## Contributing\r\n\r\nMQTT.js is an **OPEN Open Source Project**. This means that:\r\n\r\n> Individuals making significant and valuable contributions are given commit-access to the project to contribute as they see fit. This project is more like an open wiki than a standard guarded open source project.\r\n\r\nSee the [CONTRIBUTING.md](https://github.com/mqttjs/MQTT.js/blob/master/CONTRIBUTING.md) file for more details.\r\n\r\n### Contributors\r\n\r\nMQTT.js is only possible due to the excellent work of the following contributors:\r\n\r\n<table><tbody>\r\n<tr><th align=\"left\">Adam Rudd</th><td><a href=\"https://github.com/adamvr\">GitHub/adamvr</a></td><td><a href=\"http://twitter.com/adam_vr\">Twitter/@adam_vr</a></td></tr>\r\n<tr><th align=\"left\">Matteo Collina</th><td><a href=\"https://github.com/mcollina\">GitHub/mcollina</a></td><td><a href=\"http://twitter.com/matteocollina\">Twitter/@matteocollina</a></td></tr>\r\n<tr><th align=\"left\">Maxime Agor</th><td><a href=\"https://github.com/4rzael\">GitHub/4rzael</a></td><td><a href=\"http://twitter.com/4rzael\">Twitter/@4rzael</a></td></tr>\r\n</tbody></table>\r\n\r\n<a name=\"license\"></a>\r\n## License\r\n\r\nMIT\r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/mqttjs/MQTT.js.git"
  },
  "scripts": {
    "browser-build": "rimraf dist/ && mkdirp dist/ && browserify mqtt.js -s mqtt > dist/mqtt.js && uglifyjs < dist/mqtt.js > dist/mqtt.min.js",
    "browser-test": "zuul --server test/browser/server.js --local --open test/browser/test.js",
    "ci": "npm run tslint && npm run typescript-test && npm run test && codecov",
    "prepare": "npm run browser-build",
    "pretest": "standard | snazzy",
    "sauce-test": "zuul --server test/browser/server.js --tunnel ngrok -- test/browser/test.js",
    "test": "istanbul cover ./node_modules/mocha/bin/_mocha --report lcovonly --",
    "tslint": "if [[ \"`node -v`\" != \"v4.3.2\" ]]; then tslint types/**/*.d.ts; fi",
    "typescript-compile-execute": "node test/typescript/*.js",
    "typescript-compile-test": "tsc -p test/typescript/tsconfig.json",
    "typescript-test": "npm run typescript-compile-test && npm run typescript-compile-execute",
    "weapp-test": "zuul --server test/browser/server.js --local --open test/browser/wx.js"
  },
  "standard": {
    "env": [
      "mocha"
    ]
  },
  "types": "types/index.d.ts",
  "version": "2.18.8"
}
